<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Likhil Bachanaboina - Developer</title>
    
    <link rel="icon" href="/public/favicon.png" />
    <style>
      #webcam, #output {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  transform: scaleX(-1); /* mirror effect */
}

#cursor {
  position: absolute;
  width: 20px;
  height: 20px;
  background: red;
  border-radius: 50%;
  pointer-events: none;
  display: none;
}

    </style>
  </head>

  <body>
    <div id="root"></div>
   
     <!-- ===== Hand Control Elements (paste before </body>) ===== -->
<button id="handToggle" style="position:fixed;right:16px;bottom:16px;z-index:9999;">
  ✋ Enable Hand Control
</button>

<video id="cam" playsinline autoplay style="display:none;"></video>

<canvas id="overlay" style="
  position:fixed;left:0;top:0;width:100vw;height:100vh;
  pointer-events:none;z-index:9998;"></canvas>

<div id="cursor" style="
  position:fixed;left:0;top:0;width:18px;height:18px;border-radius:50%;
  border:2px solid #00e5ff;background:rgba(0,229,255,.12);
  transform:translate(-50%,-50%);pointer-events:none;z-index:9999;display:none;"></div>

<style>
  /* highlight element under hand */
  .hand-hover {
    transition: box-shadow .12s, transform .12s;
    box-shadow: 0 8px 20px rgba(0,0,0,0.18);
    transform: translateY(-4px);
  }
  /* click ripple */
  .hand-ripple {
    position: absolute;
    width: 12px; height: 12px; border-radius: 50%;
    background: rgba(0,229,255,0.55);
    transform: translate(-50%,-50%) scale(0.3);
    pointer-events: none;
    animation: ripple 420ms ease-out forwards;
    z-index: 10000;
  }
  @keyframes ripple {
    to { transform: translate(-50%,-50%) scale(4); opacity: 0; }
  }
</style>

<!-- MediaPipe -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

<script>
(() => {
  // UI elements
  const toggleBtn = document.getElementById('handToggle');
  const video = document.getElementById('cam');
  const canvas = document.getElementById('overlay');
  const ctx = canvas.getContext('2d');
  const cursor = document.getElementById('cursor');

  // state
  let camera = null;
  let hands = null;
  let enabled = false;
  let lastZ = null;
  let lastClickAt = 0;
  const CLICK_COOLDOWN = 600; // ms
  const POKE_THRESHOLD = 0.04; // tune this if too sensitive
  const SMOOTH_ALPHA = 0.35; // exponential smoothing for z

  function fitCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  fitCanvas();
  window.addEventListener('resize', fitCanvas);

  // helper to convert normalized coords to page pixels
  function pagePosFromNorm(normX, normY) {
    // NOTE: we mirror X in JS so that moving hand to right moves cursor right (keeps video mirrored)
    const x = (1 - normX) * window.innerWidth;
    const y = normY * window.innerHeight;
    return { x, y };
  }

  // move cursor using middle finger (landmark 12)
  function moveCursorFrom(lm) {
    const pos = pagePosFromNorm(lm[12].x, lm[12].y);
    cursor.style.left = pos.x + 'px';
    cursor.style.top  = pos.y + 'px';
    cursor.style.display = 'block';
    return pos;
  }

  // highlight element under cursor
  let lastHoverEl = null;
  function updateHover(pos) {
    const el = document.elementFromPoint(pos.x, pos.y);
    if (el !== lastHoverEl) {
      if (lastHoverEl) lastHoverEl.classList.remove('hand-hover');
      if (el && el !== document.body && el !== document.documentElement) {
        el.classList.add('hand-hover');
        lastHoverEl = el;
      } else {
        lastHoverEl = null;
      }
    }
  }

  // ripple effect for click
  function showRipple(x, y) {
    const r = document.createElement('div');
    r.className = 'hand-ripple';
    r.style.left = x + 'px';
    r.style.top  = y + 'px';
    document.body.appendChild(r);
    setTimeout(()=> r.remove(), 600);
  }

  // perform click (debounced)
  function doClick(pos) {
    const now = performance.now();
    if (now - lastClickAt < CLICK_COOLDOWN) return;
    lastClickAt = now;

    const el = document.elementFromPoint(pos.x, pos.y);
    if (!el) return;
    showRipple(pos.x, pos.y);

    // if it's a link or button, call click
    if (typeof el.click === 'function') {
      el.click();
    } else {
      // otherwise dispatch a synthetic pointer event (for elements that listen to pointerdown)
      const evt = new MouseEvent('click', { bubbles: true, cancelable: true, view: window });
      el.dispatchEvent(evt);
    }
  }

  // poke detector using middle finger Z (lm[12].z)
  let smoothedZ = null;
  function detectPoke(lm) {
    const z = lm[12].z;
    if (smoothedZ === null) smoothedZ = z;
    smoothedZ = smoothedZ * (1 - SMOOTH_ALPHA) + z * SMOOTH_ALPHA;

    // poke if smoothed previous - current > threshold
    const delta = (lastZ === null) ? 0 : (lastZ - smoothedZ);
    lastZ = smoothedZ;
    return delta > POKE_THRESHOLD;
  }

  // handle new results from MediaPipe
  function onResults(results) {
    ctx.clearRect(0,0,canvas.width,canvas.height);

    if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
      cursor.style.display = 'none';
      if (lastHoverEl) { lastHoverEl.classList.remove('hand-hover'); lastHoverEl = null; }
      return;
    }

    // take first hand only
    const lm = results.multiHandLandmarks[0];

    // draw a subtle ring at the palm for visual effect
    const palmX = lm[0].x * canvas.width;
    const palmY = lm[0].y * canvas.height;
    const r = 26;
    const g = ctx.createRadialGradient(palmX, palmY, r*0.25, palmX, palmY, r);
    g.addColorStop(0, 'rgba(0,229,255,0.45)');
    g.addColorStop(1, 'rgba(0,229,255,0.0)');
    ctx.fillStyle = g;
    ctx.beginPath(); ctx.arc(palmX, palmY, r, 0, Math.PI*2); ctx.fill();

    // move cursor (middle finger)
    const pos = moveCursorFrom(lm);

    // update hover highlight
    updateHover(pos);

    // detect poke-forward click
    if (detectPoke(lm)) {
      doClick(pos);
    }
  }

  // start the camera + mediapipe
  async function startHands() {
    hands = new Hands({ locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 1,
      minDetectionConfidence: 0.7,
      minTrackingConfidence: 0.6
    });
    hands.onResults(onResults);

    camera = new Camera(video, {
      onFrame: async () => { await hands.send({ image: video }); },
      width: 640,
      height: 480
    });

    await camera.start();
    enabled = true;
    toggleBtn.textContent = '✋ Hand Control: ON';
  }

  function stopHands() {
    try { camera?.stop?.(); } catch(e) {}
    enabled = false;
    toggleBtn.textContent = '✋ Enable Hand Control';
    cursor.style.display = 'none';
    ctx.clearRect(0,0,canvas.width,canvas.height);
    if (lastHoverEl) { lastHoverEl.classList.remove('hand-hover'); lastHoverEl = null; }
    smoothedZ = null; lastZ = null;
  }

  // toggle via button (good for mobile browsers that require user gesture)
  toggleBtn.addEventListener('click', async () => {
    if (!enabled) {
      try {
        await startHands();
      } catch (err) {
        alert('Camera permission denied or not available. Open page via HTTPS or localhost and allow camera.');
        console.error(err);
      }
    } else {
      stopHands();
    }
  });

  // auto-start if you want (comment out if not)
  // startHands();

})();
</script>

    <script type="module" src="/src/main.tsx"></script>
    
  </body>
</html> 
 